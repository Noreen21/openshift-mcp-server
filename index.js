#!/usr/bin/env node

/**
 * OpenShift MCP Server
 * A Model Context Protocol server for OpenShift/Kubernetes cluster monitoring
 * 
 * Generated by Cursor - AI-powered code editor
 * https://cursor.sh
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import * as k8s from '@kubernetes/client-node';

/**
 * OpenShift/Kubernetes MCP Server for cluster monitoring
 */
class OpenShiftMCPServer {
  constructor() {
    // Constants
    this.PENDING_POD_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    this.DEFAULT_RESTART_THRESHOLD = 5;
    this.DEFAULT_CPU_THRESHOLD = 80;
    this.DEFAULT_MEMORY_THRESHOLD = 85;

    // Initialize server
    this.server = new Server(
      {
        name: "openshift-mcp-server",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    try {
      // Initialize Kubernetes client
      this.initializeKubernetesClient();
      this.setupToolHandlers();
      this.setupGracefulShutdown();
    } catch (error) {
      console.error('Failed to initialize OpenShift MCP Server:', error);
      throw new Error(`Initialization failed: ${error.message}`);
    }
  }

  initializeKubernetesClient() {
    const kc = new k8s.KubeConfig();
    
    try {
      // Enhanced loading for private clusters
      if (process.env.KUBECONFIG) {
        console.error(`Loading kubeconfig from: ${process.env.KUBECONFIG}`);
        kc.loadFromFile(process.env.KUBECONFIG);
      } else if (process.env.KUBERNETES_SERVICE_HOST) {
        // Running inside cluster (in-cluster config)
        console.error('Loading in-cluster configuration');
        kc.loadFromCluster();
      } else {
        // Default locations
        console.error('Loading kubeconfig from default location');
        kc.loadFromDefault();
      }

      // Configure for private clusters with proxies
      if (process.env.HTTPS_PROXY || process.env.HTTP_PROXY) {
        console.error('Proxy configuration detected');
        // The k8s client should automatically use proxy settings from env vars
      }

      // Log cluster endpoint for debugging private cluster connectivity
      const currentContext = kc.getCurrentContext();
      if (currentContext) {
        const cluster = kc.getCurrentCluster();
        console.error(`Connected to cluster: ${cluster?.server || 'unknown'}`);
        console.error(`Using context: ${currentContext}`);
      }

      // CRITICAL FIX: Use correct API client creation
      this.k8sApi = kc.makeApiClient(k8s.CoreV1Api);
      this.metricsApi = kc.makeApiClient(k8s.Metrics);
      this.appsApi = kc.makeApiClient(k8s.AppsV1Api);
      
      console.error('Kubernetes clients initialized successfully');
      
      // Test connectivity to private cluster
      this.testClusterConnectivity();
    } catch (error) {
      console.error('Failed to initialize Kubernetes clients:', error);
      console.error('For private clusters, ensure:');
      console.error('  1. Valid kubeconfig with correct cluster endpoint');
      console.error('  2. Network connectivity to cluster API server');
      console.error('  3. Proper proxy configuration if needed');
      console.error('  4. VPN connection if required');
      throw error;
    }
  }

  async testClusterConnectivity() {
    try {
      // Quick connectivity test
      await this.k8sApi.listNamespace();
      console.error('Cluster connectivity test: SUCCESS');
    } catch (error) {
      console.warn('Cluster connectivity test failed:', error.message);
      console.warn('This may be normal for private clusters with restricted access');
    }
  }

  setupGracefulShutdown() {
    const cleanup = () => {
      console.error('Shutting down OpenShift MCP Server...');
      process.exit(0);
    };
    
    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);
  }

  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "check_cluster_health",
            description: "Check overall OpenShift cluster health and identify stability issues",
            inputSchema: {
              type: "object",
              properties: {
                detailed: {
                  type: "boolean",
                  description: "Include detailed analysis of each component",
                  default: false
                }
              }
            }
          },
          {
            name: "get_performance_metrics",
            description: "Retrieve current performance metrics for nodes and pods",
            inputSchema: {
              type: "object",
              properties: {
                namespace: {
                  type: "string",
                  description: "Specific namespace to monitor (optional)"
                },
                timeRange: {
                  type: "string",
                  description: "Time range for metrics (e.g., '1h', '24h')",
                  default: "1h"
                }
              }
            }
          },
          {
            name: "detect_resource_issues",
            description: "Detect pods and nodes with resource allocation or utilization issues",
            inputSchema: {
              type: "object",
              properties: {
                thresholds: {
                  type: "object",
                  properties: {
                    cpu: { type: "number", default: 80 },
                    memory: { type: "number", default: 85 },
                    restarts: { type: "number", default: 5 }
                  }
                }
              }
            }
          },
          {
            name: "analyze_pod_disruptions",
            description: "Analyze pod disruptions and restart patterns",
            inputSchema: {
              type: "object",
              properties: {
                namespace: {
                  type: "string",
                  description: "Namespace to analyze (optional)"
                },
                hours: {
                  type: "number",
                  description: "Number of hours to look back",
                  default: 24
                }
              }
            }
          },
          {
            name: "check_node_conditions",
            description: "Check node conditions and identify nodes with issues",
            inputSchema: {
              type: "object",
              properties: {}
            }
          },
          {
            name: "monitor_deployments",
            description: "Monitor deployment status and rollout health",
            inputSchema: {
              type: "object",
              properties: {
                namespace: {
                  type: "string",
                  description: "Namespace to monitor (optional)"
                }
              }
            }
          }
        ]
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        // Validate arguments
        this.validateToolArguments(name, args);

        switch (name) {
          case "check_cluster_health":
            return await this.checkClusterHealth(args?.detailed || false);
          
          case "get_performance_metrics":
            return await this.getPerformanceMetrics(args?.namespace, args?.timeRange);
          
          case "detect_resource_issues":
            return await this.detectResourceIssues(args?.thresholds);
          
          case "analyze_pod_disruptions":
            return await this.analyzePodDisruptions(args?.namespace, args?.hours);
          
          case "check_node_conditions":
            return await this.checkNodeConditions();
          
          case "monitor_deployments":
            return await this.monitorDeployments(args?.namespace);
          
          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error executing ${name}: ${this.sanitizeErrorMessage(error.message)}`
            }
          ],
          isError: true
        };
      }
    });
  }

  // CRITICAL FIX: Add input validation
  validateToolArguments(toolName, args) {
    if (!args) return;

    switch (toolName) {
      case 'check_cluster_health':
        if (args.detailed !== undefined && typeof args.detailed !== 'boolean') {
          throw new Error('detailed parameter must be boolean');
        }
        break;
      case 'get_performance_metrics':
        if (args.namespace && typeof args.namespace !== 'string') {
          throw new Error('namespace parameter must be string');
        }
        if (args.timeRange && typeof args.timeRange !== 'string') {
          throw new Error('timeRange parameter must be string');
        }
        break;
      case 'detect_resource_issues':
        if (args.thresholds) {
          if (typeof args.thresholds !== 'object') {
            throw new Error('thresholds parameter must be object');
          }
          const { cpu, memory, restarts } = args.thresholds;
          if (cpu !== undefined && typeof cpu !== 'number') {
            throw new Error('cpu threshold must be number');
          }
          if (memory !== undefined && typeof memory !== 'number') {
            throw new Error('memory threshold must be number');
          }
          if (restarts !== undefined && typeof restarts !== 'number') {
            throw new Error('restarts threshold must be number');
          }
        }
        break;
      case 'analyze_pod_disruptions':
        if (args.namespace && typeof args.namespace !== 'string') {
          throw new Error('namespace parameter must be string');
        }
        if (args.hours !== undefined && typeof args.hours !== 'number') {
          throw new Error('hours parameter must be number');
        }
        break;
      case 'monitor_deployments':
        if (args.namespace && typeof args.namespace !== 'string') {
          throw new Error('namespace parameter must be string');
        }
        break;
    }
  }

  // CRITICAL FIX: Sanitize error messages
  sanitizeErrorMessage(message) {
    // Remove potentially sensitive information
    return message
      .replace(/token[^,\s]*/gi, 'token[REDACTED]')
      .replace(/password[^,\s]*/gi, 'password[REDACTED]')
      .replace(/secret[^,\s]*/gi, 'secret[REDACTED]');
  }

  async checkClusterHealth(detailed = false) {
    const issues = [];
    const health = {
      overall: 'healthy',
      issues,
      metrics: {
        nodeHealth: 0,
        podHealth: 0,
        resourceUtilization: { cpu: 0, memory: 0 }
      }
    };

    try {
      // CRITICAL FIX: Use Promise.all for parallel API calls
      const [nodesResponse, podsResponse] = await Promise.all([
        this.k8sApi.listNode(),
        this.k8sApi.listPodForAllNamespaces()
      ]);
      
      const nodes = nodesResponse.body.items;
      const pods = podsResponse.body.items;
      let healthyNodes = 0;

      // Check nodes
      for (const node of nodes) {
        const conditions = node.status?.conditions || [];
        const readyCondition = conditions.find(c => c.type === 'Ready');
        
        if (readyCondition?.status === 'True') {
          healthyNodes++;
        } else {
          issues.push(`Node ${node.metadata?.name} is not ready`);
        }

        // Check for node conditions indicating issues
        const problemConditions = conditions.filter(c => 
          c.type !== 'Ready' && c.status === 'True'
        );
        
        for (const condition of problemConditions) {
          issues.push(`Node ${node.metadata?.name}: ${condition.type} - ${condition.message}`);
        }
      }

      health.metrics.nodeHealth = nodes.length > 0 ? (healthyNodes / nodes.length) * 100 : 0;

      // Check pods
      let healthyPods = 0;
      for (const pod of pods) {
        const phase = pod.status?.phase;
        if (phase === 'Running' || phase === 'Succeeded') {
          healthyPods++;
        } else if (phase === 'Failed' || phase === 'Pending') {
          const age = this.calculateAge(pod.metadata?.creationTimestamp);
          if (phase === 'Pending' && age > this.PENDING_POD_TIMEOUT) {
            issues.push(`Pod ${pod.metadata?.name} in ${pod.metadata?.namespace} stuck in Pending state`);
          } else if (phase === 'Failed') {
            issues.push(`Pod ${pod.metadata?.name} in ${pod.metadata?.namespace} in Failed state`);
          }
        }

        // Check for excessive restarts
        const containerStatuses = pod.status?.containerStatuses || [];
        for (const container of containerStatuses) {
          if (container.restartCount > this.DEFAULT_RESTART_THRESHOLD) {
            issues.push(`Container ${container.name} in pod ${pod.metadata?.name} has ${container.restartCount} restarts`);
          }
        }
      }

      health.metrics.podHealth = pods.length > 0 ? (healthyPods / pods.length) * 100 : 0;

      // Determine overall health
      if (issues.length === 0) {
        health.overall = 'healthy';
      } else if (issues.length <= 3 && health.metrics.nodeHealth > 90 && health.metrics.podHealth > 95) {
        health.overall = 'warning';
      } else {
        health.overall = 'critical';
      }

      const summary = {
        status: health.overall,
        totalNodes: nodes.length,
        healthyNodes,
        totalPods: pods.length,
        healthyPods,
        issuesFound: issues.length,
        ...(detailed && { detailedIssues: issues })
      };

      return {
        content: [
          {
            type: "text",
            text: `Cluster Health Report:\n${JSON.stringify(summary, null, 2)}`
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to check cluster health: ${error.message}`);
    }
  }

  async getPerformanceMetrics(namespace, timeRange = '1h') {
    try {
      const metrics = {
        timestamp: new Date().toISOString(),
        nodes: [],
        pods: []
      };

      // Get node metrics with error handling
      try {
        const nodeMetrics = await this.metricsApi.getNodeMetrics();
        for (const node of nodeMetrics.items) {
          const nodeInfo = await this.k8sApi.readNode(node.metadata.name);
          metrics.nodes.push({
            name: node.metadata.name,
            cpu: this.parseResourceValue(node.usage.cpu),
            memory: this.parseResourceValue(node.usage.memory),
            status: nodeInfo.body.status?.conditions?.find(c => c.type === 'Ready')?.status || 'Unknown'
          });
        }
      } catch (error) {
        console.warn('Could not retrieve node metrics:', error.message);
        metrics.nodes.push({ error: 'Metrics unavailable - check metrics-server deployment' });
      }

      // Get pod metrics with error handling
      try {
        const podMetrics = await this.metricsApi.getPodMetrics(namespace);
        const podsResponse = namespace 
          ? await this.k8sApi.listNamespacedPod(namespace)
          : await this.k8sApi.listPodForAllNamespaces();
        
        const pods = podsResponse.body.items;

        for (const podMetric of podMetrics.items) {
          const pod = pods.find(p => 
            p.metadata?.name === podMetric.metadata.name && 
            p.metadata?.namespace === podMetric.metadata.namespace
          );

          if (pod) {
            const totalCpu = podMetric.containers.reduce((sum, c) => 
              sum + this.parseResourceValue(c.usage.cpu), 0
            );
            const totalMemory = podMetric.containers.reduce((sum, c) => 
              sum + this.parseResourceValue(c.usage.memory), 0
            );

            const restarts = pod.status?.containerStatuses?.reduce((sum, c) => sum + c.restartCount, 0) || 0;

            metrics.pods.push({
              name: pod.metadata?.name || '',
              namespace: pod.metadata?.namespace || '',
              cpu: totalCpu,
              memory: totalMemory,
              restarts,
              age: this.formatAge(pod.metadata?.creationTimestamp)
            });
          }
        }
      } catch (error) {
        console.warn('Could not retrieve pod metrics:', error.message);
        metrics.pods.push({ error: 'Pod metrics unavailable - check metrics-server deployment' });
      }

      return {
        content: [
          {
            type: "text",
            text: `Performance Metrics Report:\n${JSON.stringify(metrics, null, 2)}`
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to get performance metrics: ${error.message}`);
    }
  }

  async detectResourceIssues(thresholds = {}) {
    const defaultThresholds = {
      cpu: this.DEFAULT_CPU_THRESHOLD,
      memory: this.DEFAULT_MEMORY_THRESHOLD,
      restarts: this.DEFAULT_RESTART_THRESHOLD
    };
    const finalThresholds = { ...defaultThresholds, ...thresholds };

    try {
      const issues = {
        highCpuPods: [],
        highMemoryPods: [],
        frequentRestartPods: [],
        resourceQuotaIssues: []
      };

      // Check pods for resource issues
      const podsResponse = await this.k8sApi.listPodForAllNamespaces();
      const pods = podsResponse.body.items;

      for (const pod of pods) {
        // Check restart count
        const containerStatuses = pod.status?.containerStatuses || [];
        const totalRestarts = containerStatuses.reduce((sum, c) => sum + c.restartCount, 0);
        
        if (totalRestarts >= finalThresholds.restarts) {
          issues.frequentRestartPods.push({
            name: pod.metadata?.name,
            namespace: pod.metadata?.namespace,
            restarts: totalRestarts,
            containers: containerStatuses.map(c => ({
              name: c.name,
              restarts: c.restartCount,
              reason: c.lastState?.terminated?.reason
            }))
          });
        }

        // Check resource requests vs limits
        const containers = pod.spec?.containers || [];
        for (const container of containers) {
          const resources = container.resources;
          if (resources?.requests && resources?.limits) {
            const cpuRequest = this.parseResourceValue(resources.requests.cpu || '0');
            const cpuLimit = this.parseResourceValue(resources.limits.cpu || '0');
            const memRequest = this.parseResourceValue(resources.requests.memory || '0');
            const memLimit = this.parseResourceValue(resources.limits.memory || '0');

            if (cpuLimit > 0 && (cpuRequest / cpuLimit) * 100 > finalThresholds.cpu) {
              issues.highCpuPods.push({
                pod: pod.metadata?.name,
                namespace: pod.metadata?.namespace,
                container: container.name,
                cpuRequestPercent: (cpuRequest / cpuLimit) * 100
              });
            }

            if (memLimit > 0 && (memRequest / memLimit) * 100 > finalThresholds.memory) {
              issues.highMemoryPods.push({
                pod: pod.metadata?.name,
                namespace: pod.metadata?.namespace,
                container: container.name,
                memoryRequestPercent: (memRequest / memLimit) * 100
              });
            }
          }
        }
      }

      return {
        content: [
          {
            type: "text",
            text: `Resource Issues Report:\n${JSON.stringify(issues, null, 2)}`
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to detect resource issues: ${error.message}`);
    }
  }

  async analyzePodDisruptions(namespace, hours = 24) {
    try {
      const disruptions = {
        recentRestarts: [],
        evictions: [],
        oomKills: [],
        summary: {
          totalRestarts: 0,
          totalEvictions: 0,
          totalOOMKills: 0
        }
      };

      const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000);
      
      // Get events to analyze disruptions
      const eventsResponse = namespace 
        ? await this.k8sApi.listNamespacedEvent(namespace)
        : await this.k8sApi.listEventForAllNamespaces();
      
      const events = eventsResponse.body.items;

      for (const event of events) {
        const eventTime = new Date(event.firstTimestamp || event.eventTime);
        if (eventTime < cutoffTime) continue;

        if (event.reason === 'Killing' || event.reason === 'Evicted') {
          disruptions.evictions.push({
            pod: event.involvedObject.name,
            namespace: event.involvedObject.namespace,
            reason: event.reason,
            message: event.message,
            time: eventTime.toISOString()
          });
          disruptions.summary.totalEvictions++;
        }

        if (event.reason === 'OOMKilling') {
          disruptions.oomKills.push({
            pod: event.involvedObject.name,
            namespace: event.involvedObject.namespace,
            message: event.message,
            time: eventTime.toISOString()
          });
          disruptions.summary.totalOOMKills++;
        }

        if (event.reason === 'Started' && event.message?.includes('Started container')) {
          disruptions.recentRestarts.push({
            pod: event.involvedObject.name,
            namespace: event.involvedObject.namespace,
            container: this.extractContainerName(event.message),
            time: eventTime.toISOString()
          });
          disruptions.summary.totalRestarts++;
        }
      }

      return {
        content: [
          {
            type: "text",
            text: `Pod Disruption Analysis (last ${hours}h):\n${JSON.stringify(disruptions, null, 2)}`
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to analyze pod disruptions: ${error.message}`);
    }
  }

  async checkNodeConditions() {
    try {
      const nodeIssues = [];
      const nodesResponse = await this.k8sApi.listNode();
      const nodes = nodesResponse.body.items;

      for (const node of nodes) {
        const conditions = node.status?.conditions || [];
        const nodeInfo = {
          name: node.metadata?.name,
          conditions: [],
          taints: node.spec?.taints || [],
          allocatable: node.status?.allocatable,
          capacity: node.status?.capacity
        };

        for (const condition of conditions) {
          if (condition.type === 'Ready' && condition.status !== 'True') {
            nodeInfo.conditions.push({
              type: condition.type,
              status: condition.status,
              reason: condition.reason,
              message: condition.message,
              severity: 'critical'
            });
          } else if (condition.type !== 'Ready' && condition.status === 'True') {
            nodeInfo.conditions.push({
              type: condition.type,
              status: condition.status,
              reason: condition.reason,
              message: condition.message,
              severity: this.getConditionSeverity(condition.type)
            });
          }
        }

        if (nodeInfo.conditions.length > 0 || nodeInfo.taints.length > 0) {
          nodeIssues.push(nodeInfo);
        }
      }

      return {
        content: [
          {
            type: "text",
            text: `Node Conditions Report:\n${JSON.stringify({ 
              totalNodes: nodes.length,
              nodesWithIssues: nodeIssues.length,
              details: nodeIssues 
            }, null, 2)}`
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to check node conditions: ${error.message}`);
    }
  }

  async monitorDeployments(namespace) {
    try {
      const deploymentIssues = [];
      const deploymentsResponse = namespace
        ? await this.appsApi.listNamespacedDeployment(namespace)
        : await this.appsApi.listDeploymentForAllNamespaces();
      
      const deployments = deploymentsResponse.body.items;

      for (const deployment of deployments) {
        const status = deployment.status;
        const spec = deployment.spec;
        
        const deploymentInfo = {
          name: deployment.metadata?.name,
          namespace: deployment.metadata?.namespace,
          replicas: {
            desired: spec?.replicas || 0,
            ready: status?.readyReplicas || 0,
            available: status?.availableReplicas || 0,
            updated: status?.updatedReplicas || 0
          },
          conditions: status?.conditions || [],
          issues: []
        };

        // Check for deployment issues
        if (deploymentInfo.replicas.ready < deploymentInfo.replicas.desired) {
          deploymentInfo.issues.push(`Only ${deploymentInfo.replicas.ready}/${deploymentInfo.replicas.desired} replicas ready`);
        }

        if (deploymentInfo.replicas.available < deploymentInfo.replicas.desired) {
          deploymentInfo.issues.push(`Only ${deploymentInfo.replicas.available}/${deploymentInfo.replicas.desired} replicas available`);
        }

        const failedConditions = deploymentInfo.conditions.filter(c => c.status === 'False');
        for (const condition of failedConditions) {
          deploymentInfo.issues.push(`${condition.type}: ${condition.message}`);
        }

        if (deploymentInfo.issues.length > 0) {
          deploymentIssues.push(deploymentInfo);
        }
      }

      return {
        content: [
          {
            type: "text",
            text: `Deployment Monitor Report:\n${JSON.stringify({
              totalDeployments: deployments.length,
              deploymentsWithIssues: deploymentIssues.length,
              details: deploymentIssues
            }, null, 2)}`
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to monitor deployments: ${error.message}`);
    }
  }

  // CRITICAL FIX: Improved resource parsing
  parseResourceValue(value) {
    if (!value || typeof value !== 'string') return 0;
    
    const numValue = parseFloat(value);
    if (isNaN(numValue)) return 0;
    
    // CPU: handle cores and millicores
    if (value.endsWith('m')) {
      return numValue / 1000; // millicores to cores
    }
    if (value.match(/^\d+(\.\d+)?$/)) {
      return numValue; // cores
    }
    
    // Memory: handle various units
    const memoryUnits = {
      'Ki': 1024,
      'Mi': 1024 * 1024,
      'Gi': 1024 * 1024 * 1024,
      'Ti': 1024 * 1024 * 1024 * 1024,
      'K': 1000,
      'M': 1000 * 1000,
      'G': 1000 * 1000 * 1000,
      'T': 1000 * 1000 * 1000 * 1000
    };
    
    for (const [unit, multiplier] of Object.entries(memoryUnits)) {
      if (value.endsWith(unit)) {
        return numValue * multiplier;
      }
    }
    
    return numValue; // bytes
  }

  calculateAge(timestamp) {
    if (!timestamp) return 0;
    return Date.now() - new Date(timestamp).getTime();
  }

  formatAge(timestamp) {
    if (!timestamp) return 'unknown';
    const age = this.calculateAge(timestamp);
    const days = Math.floor(age / (24 * 60 * 60 * 1000));
    const hours = Math.floor((age % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
    const minutes = Math.floor((age % (60 * 60 * 1000)) / (60 * 1000));
    
    if (days > 0) return `${days}d${hours}h`;
    if (hours > 0) return `${hours}h${minutes}m`;
    return `${minutes}m`;
  }

  getConditionSeverity(conditionType) {
    const criticalConditions = ['OutOfDisk', 'MemoryPressure', 'DiskPressure'];
    const warningConditions = ['PIDPressure', 'NetworkUnavailable'];
    
    if (criticalConditions.includes(conditionType)) return 'critical';
    if (warningConditions.includes(conditionType)) return 'warning';
    return 'info';
  }

  extractContainerName(message) {
    const match = message.match(/Started container (.+)/);
    return match ? match[1] : 'unknown';
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("OpenShift MCP Server running on stdio");
  }
}

// Initialize and run the server
const server = new OpenShiftMCPServer();
server.run().catch((error) => {
  console.error('Failed to start OpenShift MCP Server:', error);
  process.exit(1);
});